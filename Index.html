<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
<meta name="theme-color" content="#111111" />
<title>Bench Boss: Netball V2</title>
<link rel="manifest" href="manifest.json">
<link rel="apple-touch-icon" href="apple-touch-icon.png">
<link rel="icon" href="favicon.png" type="image/png">
<!-- build: v2-regenerated -->
<style>
  :root { --pad:12px; --r:12px; --b:1px solid #ddd; --accent:#111; }
  body{margin:0;font-family:-apple-system,system-ui,Segoe UI,Roboto,Arial;background:#f6f6f6;color:#111}
  header{padding:14px;background:linear-gradient(135deg,#0b0b0b,#1a1a1a);color:#fff;display:flex;align-items:center;justify-content:space-between}
  .brand{display:flex;gap:12px;align-items:center}
  .brand img{width:44px;height:44px;border-radius:10px;object-fit:cover}
  .brand h1{margin:0;font-size:18px}
  main{padding:var(--pad);display:grid;gap:var(--pad)}
  .card{background:#fff;border:var(--b);border-radius:var(--r);padding:var(--pad)}
  .row{display:flex;gap:10px;align-items:center;flex-wrap:wrap}
  .grow{flex:1}
  .muted{color:#666;font-size:13px}
  button.primary{background:var(--accent);color:#fff;border-radius:10px;padding:8px 12px;border:1px solid var(--accent);font-weight:800}
  button.ghost{background:#fff;border-radius:10px;padding:8px 12px;border:var(--b);font-weight:800}
  input[type="text"],select,input[type="date"],textarea{border:var(--b);border-radius:10px;padding:8px 10px;font-size:15px}
  textarea{min-height:80px}
  .seg{display:flex;gap:8px;flex-wrap:wrap}
  .seg button{border:var(--b);background:#fff;padding:8px 10px;border-radius:999px}
  .seg button.active{background:var(--accent);color:#fff;border-color:var(--accent)}
  .pill{display:flex;justify-content:space-between;align-items:center;padding:8px 10px;border:var(--b);border-radius:10px;background:#fff}
  .small{font-size:13px;padding:6px 8px}
  .posTag{width:48px;text-align:center;padding:8px;border-radius:8px;background:#f4f4f4;border:var(--b);font-weight:900}
  .posRow{display:flex;gap:8px;align-items:center;margin-bottom:8px}
  .scoreBig{font-size:40px;font-weight:900}
  .kbd{font-family:ui-monospace,Menlo,monospace;font-size:12px;padding:2px 6px;border-radius:8px;background:#eee;border:1px solid #ddd}
  .modalBack{position:fixed;inset:0;background:rgba(0,0,0,.45);display:none;align-items:center;justify-content:center;padding:16px;z-index:999}
  .modal{width:min(880px,100%);background:#fff;border-radius:12px;padding:12px;border:1px solid #ddd}
  .rollBtn{border:1px solid #ddd;background:#fff;border-radius:10px;padding:6px 8px;margin-right:8px;font-weight:800}
  .card.collapsed .cardBody{display:none}
  .warn{background:#fff8e1;border:1px solid #ffe082;padding:8px;border-radius:8px}
  .finalBanner{display:none;padding:10px;border-radius:10px;border:1px solid #ddd;margin-top:10px}
  .finalBanner.win{background:#e8f5e9;border-color:#c8e6c9}
  .finalBanner.loss{background:#ffebee;border-color:#ffcdd2}
  .finalBanner.draw{background:#e3f2fd;border-color:#bbdefb}
  .grid2{display:grid;grid-template-columns:1fr;gap:10px}
  @media(min-width:900px){.grid2{grid-template-columns:1fr 360px}}
</style>
</head>
<body>

<header>
  <div class="brand">
    <img src="bb-netball.png" alt="Bench Boss logo" onerror="this.style.display='none'">
    <div>
      <h1>Bench Boss: Netball V2</h1>
      <div class="muted">Rotations â€¢ scoring â€¢ timer â€¢ tournaments</div>
    </div>
  </div>
  <div style="display:flex;gap:8px;align-items:center">
    <button class="ghost small" id="howToBtn">How-to</button>
    <div id="saveState" class="muted"></div>
  </div>
</header>

<main>

  <!-- Competition / Team workflow -->
  <section class="card" id="compCard">
    <div class="row">
      <div class="grow">
        <div style="font-weight:900">Competitions</div>
        <div class="muted">Create a competition first (season / tournament), then add teams under it.</div>
      </div>
      <button class="primary" id="addCompBtn">+ Add Competition</button>
    </div>

    <div style="height:10px"></div>

    <div class="row">
      <div class="grow">
        <div class="muted">Competitions</div>
        <div class="seg" id="compSeg"></div>
      </div>
      <div style="width:280px">
        <div class="muted">Teams (selected comp)</div>
        <div class="seg" id="teamSeg"></div>
      </div>
    </div>

    <div style="height:10px"></div>

    <div class="row">
      <div class="grow">
        <button class="ghost small" id="addTeamBtn">+ Add Team</button>
        <button class="ghost small" id="duplicateTeamBtn">Duplicate Team</button>
        <button class="ghost small danger" id="deleteTeamBtn">Delete Team</button>
      </div>
      <div>
        <button class="ghost small" id="exportBtn">Export</button>
        <button class="ghost small" id="importBtn">Import</button>
      </div>
    </div>
  </section>

  <!-- Top game header -->
  <section class="card" id="gameCard">
    <div class="row">
      <div class="grow">
        <div style="font-weight:900">Game</div>
        <div class="muted">Name / date / opponent</div>
      </div>
      <div>
        <button class="ghost small" id="addGameBtn">+ Add Game</button>
        <button class="ghost small" id="activateFinalsBtn">Activate Finals</button>
      </div>
    </div>

    <div style="height:10px"></div>

    <div class="row">
      <div class="grow"><input id="teamName" type="text" placeholder="Team name"></div>
      <div style="width:200px"><input id="gameName" type="text" placeholder="Game name"></div>
      <div style="width:150px"><input id="gameDate" type="date"></div>
      <div style="width:180px"><input id="opponent" type="text" placeholder="Opponent"></div>
    </div>

    <div style="height:8px"></div>

    <div class="row">
      <div class="muted">Games:</div>
      <div class="seg" id="roundSeg"></div>
    </div>
  </section>

  <div class="grid2">
    <!-- Left column: players, positions, bench -->
    <div>

      <!-- Players: modal-driven -->
      <section class="card" id="playersCard">
        <div class="row">
          <div class="grow"><div style="font-weight:900">Players</div><div class="muted">Add or import players. Max 15.</div></div>
          <div>
            <button class="primary small" id="openAddPlayerModal">+ Player</button>
            <button class="ghost small" id="importPlayersBtn">Import</button>
          </div>
        </div>

        <div style="height:10px"></div>
        <div id="playersList"></div>
      </section>

      <!-- Period / scoring / timer -->
      <section class="card" id="periodCard">
        <div class="row">
          <div class="grow" style="font-weight:900">Scoring & Timer</div>
          <div class="seg" id="periodSeg"></div>
        </div>

        <div style="height:8px"></div>
        <div class="row">
          <div>
            <div class="scoreBig" id="homeScore">0</div>
            <div class="muted" id="homeLabel">Home</div>
          </div>

          <div style="flex:1"></div>

          <div>
            <div class="scoreBig" id="awayScore">0</div>
            <div class="muted" id="awayLabel">Away</div>
          </div>
        </div>

        <div style="height:10px"></div>

        <div class="row">
          <button class="primary" id="homePlus">Home +1</button>
          <button class="primary" id="gsPlus">+GS (<span id="gsName">â€”</span>)</button>
          <button class="primary" id="gaPlus">+GA (<span id="gaName">â€”</span>)</button>
          <button class="ghost" id="homeMinus">Home âˆ’1</button>

          <div class="grow"></div>

          <button class="primary" id="awayPlus">Away +1</button>
          <button class="ghost" id="awayMinus">Away âˆ’1</button>
          <button class="ghost" id="undoBtn">Undo</button>
        </div>

        <div style="height:12px"></div>

        <div class="row" style="align-items:center">
          <div class="muted">Timer:</div>
          <div id="timerDisplay" style="font-weight:900;margin-left:6px">10:00</div>
          <select id="minutesSelect" style="margin-left:8px"></select>
          <button class="primary small" id="timerStartBtn">Start</button>
          <button class="ghost small" id="timerResetBtn">Reset</button>
        </div>

        <div id="finalBanner" class="finalBanner"><div id="finalBannerText" style="font-weight:900"></div></div>
      </section>

      <!-- Positions (all periods) -->
      <section class="card" id="positionsCard">
        <div class="row">
          <div class="grow" style="font-weight:900">Positions (this game â€” all periods)</div>
          <div>
            <button class="ghost small" id="copyToNextBtn">Copy to next</button>
            <button class="ghost small" id="generateBtn">Generate Teams</button>
          </div>
        </div>

        <div style="height:10px"></div>

        <!-- We show all periods positions in one area -->
        <div id="allPeriodsGrid"></div>

        <div style="height:10px"></div>
        <div style="font-weight:900">Bench (per selected period)</div>
        <div id="benchList"></div>
      </section>
    </div>

    <!-- Right column: stats & summary -->
    <div>
      <section class="card" id="statsCard">
        <div class="row">
          <div class="grow" style="font-weight:900">Stats / Summary</div>
          <div class="muted">Game + competition totals</div>
        </div>

        <div style="height:10px"></div>
        <div id="statsList"></div>

        <div style="height:12px"></div>
        <div>
          <button class="ghost small" id="copySummaryBtn">Copy Summary</button>
          <button class="ghost small" id="copySeasonBtn">Copy Competition Summary</button>
        </div>
      </section>

      <section class="card" id="notesCard">
        <div style="font-weight:900">Notes</div>
        <div style="height:8px"></div>
        <textarea id="notes" placeholder="Notes for this game"></textarea>
      </section>
    </div>
  </div>
</main>

<!-- MODALS -->

<!-- Add Competition -->
<div class="modalBack" id="compModal">
  <div class="modal">
    <div class="row">
      <h3 class="grow">Add Competition</h3>
      <button class="ghost small" id="closeCompModal">Close</button>
    </div>
    <div style="height:8px"></div>
    <div class="muted">Competition name</div>
    <input id="compNameField" type="text" placeholder="e.g. Parkville Comp 2026">
    <div style="height:8px"></div>
    <div class="row">
      <label style="display:flex;align-items:center;gap:8px"><input type="checkbox" id="compSeparateTeams"> Keep teams separate per competition</label>
      <div class="grow"></div>
      <button class="primary" id="createCompBtn">Create</button>
    </div>
  </div>
</div>

<!-- Add Team -->
<div class="modalBack" id="teamModal">
  <div class="modal">
    <div class="row">
      <h3 class="grow">Add Team</h3>
      <button class="ghost small" id="closeTeamModal">Close</button>
    </div>

    <div style="height:8px"></div>
    <div class="muted">Team name</div>
    <input id="newTeamName" type="text" placeholder="Team name">

    <div style="height:8px"></div>
    <div class="muted">Format</div>
    <label><input type="radio" name="teamFormat" value="quarters" checked> 4 quarters (league)</label>
    <label style="margin-left:8px"><input type="radio" name="teamFormat" value="halves"> 2 halves (tournament)</label>

    <div style="height:8px"></div>
    <div class="muted">Import players from existing team (optional)</div>
    <select id="importFromSelect"></select>
    <div style="height:8px"></div>

    <div class="row">
      <button class="primary" id="createTeamBtn">Create Team</button>
      <div class="grow"></div>
      <button class="ghost small" id="importPlayersFromTeamBtn">Import</button>
    </div>
  </div>
</div>

<!-- Add / Edit Player Modal -->
<div class="modalBack" id="playerModal">
  <div class="modal">
    <div class="row">
      <h3 class="grow" id="playerModalTitle">Add Player</h3>
      <button class="ghost small" id="closePlayerModal">Close</button>
    </div>

    <div style="height:8px"></div>

    <div class="row">
      <div class="grow">
        <div class="muted">Player name</div>
        <input id="playerNameField" type="text" placeholder="Full name">
      </div>
      <div style="width:180px">
        <div class="muted">Position 1</div>
        <input id="pos1Field" type="text" placeholder="Type to filter (e.g. W)">
      </div>
      <div style="width:180px">
        <div class="muted">Position 2</div>
        <input id="pos2Field" type="text" placeholder="Type to filter">
      </div>
    </div>

    <div style="height:8px"></div>
    <div class="row">
      <div class="grow"></div>
      <button class="primary" id="savePlayerBtn">Save</button>
    </div>
  </div>
</div>

<!-- Generate Teams Modal -->
<div class="modalBack" id="generateModal">
  <div class="modal">
    <div class="row">
      <h3 class="grow">Generate Teams for Tournament</h3>
      <button class="ghost small" id="closeGenerateModal">Close</button>
    </div>
    <div style="height:8px"></div>
    <div class="muted">Number of games to generate</div>
    <input id="generateGamesCount" type="number" min="1" max="20" value="5">
    <div style="height:8px"></div>
    <label><input type="checkbox" id="generateOverwrite"> Overwrite existing generated games (keeps manually added games)</label>
    <div style="height:12px"></div>
    <div class="row">
      <button class="primary" id="runGenerateBtn">Generate</button>
    </div>
  </div>
</div>

<!-- Sync/Export Modal -->
<div class="modalBack" id="syncModal">
  <div class="modal">
    <div class="row">
      <h3 class="grow">Export / Import</h3>
      <button class="ghost small" id="closeSyncModal">Close</button>
    </div>
    <div style="height:8px"></div>
    <textarea id="syncTextarea" placeholder="Paste exported JSON here"></textarea>
    <div style="height:8px"></div>
    <div class="row">
      <button class="primary" id="exportTeamBtn">Export</button>
      <button class="ghost" id="importTeamBtn">Import (Replace)</button>
    </div>
  </div>
</div>

<script>
/* ==========================
   Data model in localStorage:
   competitionsIndex => {comps:[{id,name,teams:[{id,name,...}]}], currentCompId, currentTeamId}
   Each team saved separately under key team_{id}
   ========================== */

const COMP_INDEX_KEY = "benchboss_comp_index_v2";
const TEAM_KEY_PREFIX = "benchboss_team_";
const POSITIONS = ["GS","GA","WA","C","WD","GD","GK"];
const MIN_PLAYERS = 7;
const MAX_PLAYERS = 15;
const LEAGUE_MINUTES = [10,12,15];
const TOURN_MINUTES = [5,6,7,8,9,10];
const OT_DEFAULT = 3;
const TOURN_DEFAULT = 8;
const LEAGUE_DEFAULT = 10;

function uid(){ return crypto.randomUUID(); }
function safeParse(x){try{return JSON.parse(x)}catch{return null} }
function loadIndex(){ return safeParse(localStorage.getItem(COMP_INDEX_KEY)) || { comps:[], currentCompId:null, currentTeamId:null } }
function saveIndex(idx){ localStorage.setItem(COMP_INDEX_KEY, JSON.stringify(idx)); }
function teamKey(id){ return TEAM_KEY_PREFIX + id }
function loadTeam(id){ return safeParse(localStorage.getItem(teamKey(id))) }
function saveTeam(id, state){ localStorage.setItem(teamKey(id), JSON.stringify(state)) }

// in-memory
let indexStore = loadIndex();
let currentTeamState = null;

/* ---------- helpers ---------- */
function show(el){ el.style.display = "flex" }
function hide(el){ el.style.display = "none" }
function byId(id){ return document.getElementById(id) }
function now(){ return Date.now() }

/* ---------- ensure structure ---------- */

function ensureTeamState(){
  if(!indexStore.comps) indexStore = { comps:[], currentCompId:null, currentTeamId:null };
  if(!indexStore.currentCompId && indexStore.comps.length) indexStore.currentCompId = indexStore.comps[0].id;
  if(!indexStore.currentTeamId){
    const comp = indexStore.comps.find(c=>c.id===indexStore.currentCompId);
    if(comp && comp.teams && comp.teams.length) indexStore.currentTeamId = comp.teams[0].id;
  }
  if(indexStore.currentTeamId){
    currentTeamState = loadTeam(indexStore.currentTeamId) || defaultTeamState();
  } else {
    currentTeamState = null;
  }
}

/* ---------- defaults ---------- */
function defaultTeamState(format="quarters"){
  const players = Array.from({length:10},(_,i)=>({ id: uid(), name:`Player ${i+1}`, pos1:"", pos2:"" }));
  return {
    id: uid(),
    teamName:"",
    format,
    players,
    games: [ newEmptyGame(1, players, format) ],
    currentGameIndex: 0
  };
}

function emptyPeriod(){ return { assignments:{}, homeScore:0, awayScore:0, events:[] } }
function basePeriods(format){ return format==="halves" ? 2 : 4 }
function newEmptyGame(roundNumber, players, format){
  return {
    round: roundNumber,
    roundName: "",
    gameDate: "",
    opponent: "",
    selectedP: 0,
    liveP: 0,
    otCount:0,
    otMinutes: OT_DEFAULT,
    gameEnded:false,
    baseMinutes: format==="halves"? TOURN_DEFAULT : LEAGUE_DEFAULT,
    timerRunning:false,
    timerRemaining:(format==="halves"?TOURN_DEFAULT:LEAGUE_DEFAULT)*60,
    timerLastTick:0,
    timerMode:"countdown",
    periods: Array.from({length: basePeriods(format)}, ()=> emptyPeriod()),
    playerStats: {}, // playerId -> {goalsTotal, goalsByP:[]}
    plannedPositions: {},
    playCredits: {} // playCredits[periodIdx][playerId]=0.5 for subs
  }
}

/* ---------- storage helpers ---------- */
function saveAll(){ if(indexStore.currentTeamId && currentTeamState) saveTeam(indexStore.currentTeamId, currentTeamState); saveIndex(indexStore); const s=byId("saveState"); if(s){s.textContent="Saved âœ“"; setTimeout(()=>s.textContent="",700)}}

/* ---------- renderers ---------- */
function renderCompTabs(){
  const seg = byId("compSeg"); seg.innerHTML = "";
  indexStore.comps.forEach(c=>{
    const b = document.createElement("button");
    b.textContent = c.name || "Comp";
    b.className = (c.id===indexStore.currentCompId) ? "active" : "";
    b.addEventListener("click", ()=> { indexStore.currentCompId = c.id; // switch comp
                                      // pick first team if any
                                      const comp = indexStore.comps.find(x=>x.id===c.id);
                                      indexStore.currentTeamId = (comp.teams && comp.teams[0])? comp.teams[0].id : null;
                                      ensureTeamState(); saveAll(); renderAll(); });
    seg.appendChild(b);
  });
}

function renderTeamTabs(){
  const seg = byId("teamSeg"); seg.innerHTML = "";
  const comp = indexStore.comps.find(c=>c.id===indexStore.currentCompId);
  if(!comp) return;
  (comp.teams || []).forEach(t=>{
    const b = document.createElement("button");
    b.textContent = t.name || "Team";
    b.className = (t.id===indexStore.currentTeamId) ? "active" : "";
    b.addEventListener("click", ()=> { indexStore.currentTeamId = t.id; ensureTeamState(); saveAll(); renderAll(); });
    seg.appendChild(b);
  });
  // importFromSelect
  const importSel = byId("importFromSelect"); importSel.innerHTML = "";
  const opt0 = document.createElement("option"); opt0.value=""; opt0.textContent="â€” select team â€”"; importSel.appendChild(opt0);
  indexStore.comps.forEach(c=>{
    c.teams.forEach(t=>{
      const opt = document.createElement("option"); opt.value = t.id; opt.textContent = `${c.name} â€¢ ${t.name}`; importSel.appendChild(opt);
    });
  });
}

function renderGameHeader(){
  if(!currentTeamState){ byId("gameCard").style.display="none"; return; }
  byId("gameCard").style.display="block";
  const g = currentGame();
  byId("teamName").value = currentTeamState.teamName || "";
  byId("gameName").value = g.roundName || "";
  byId("gameDate").value = g.gameDate || "";
  byId("opponent").value = g.opponent || "";
  // rounds
  const rs = byId("roundSeg"); rs.innerHTML = "";
  currentTeamState.games.forEach((gg,i)=>{
    const b = document.createElement("button"); b.textContent = `G${gg.round}`; b.className = (i===currentTeamState.currentGameIndex) ? "active":"";
    b.addEventListener("click", ()=> { currentTeamState.currentGameIndex = i; saveAll(); renderAll();});
    rs.appendChild(b);
  });
}

function currentGame(){ return currentTeamState.games[currentTeamState.currentGameIndex] }

function renderPlayers(){
  if(!currentTeamState){ byId("playersCard").style.display="none"; return; }
  byId("playersCard").style.display="block";
  const wrap = byId("playersList"); wrap.innerHTML = "";
  currentTeamState.players.forEach((p, idx)=>{
    const div = document.createElement("div"); div.className="pill";
    const left = document.createElement("div"); left.innerHTML = `<div style="font-weight:900">${escapeHtml(p.name)}</div><div class="muted">Pos: ${p.pos1||"â€”"} ${p.pos2?(" / "+p.pos2):""}</div>`;
    const right = document.createElement("div");
    const edit = document.createElement("button"); edit.className="ghost small"; edit.textContent="Edit";
    edit.addEventListener("click", ()=> openPlayerModal(p));
    const del = document.createElement("button"); del.className="miniDanger"; del.textContent="âˆ’";
    del.addEventListener("click", ()=> removePlayer(p.id));
    right.appendChild(edit); right.appendChild(del);
    div.appendChild(left); div.appendChild(right);
    wrap.appendChild(div);
  });
}

function renderPeriodSeg(){
  if(!currentTeamState) return;
  const g = currentGame();
  const seg = byId("periodSeg"); seg.innerHTML="";
  const total = basePeriods(currentTeamState.format) + (g.otCount || 0);
  for(let i=0;i<total;i++){
    const b = document.createElement("button"); b.textContent = periodLabel(i); b.className = (g.selectedP===i) ? "active" : "";
    b.addEventListener("click", ()=> { g.selectedP = i; resetTimer(); saveAll(); renderAll(); });
    seg.appendChild(b);
  }
}

function periodLabel(idx){
  const base = basePeriods(currentTeamState.format);
  if(idx < base) return currentTeamState.format==="halves" ? `H${idx+1}` : `Q${idx+1}`;
  return `OT${idx-base+1}`;
}

function totalPeriodsForGame(g){
  return basePeriods(currentTeamState.format) + (g.otCount||0);
}

function renderAllPeriodsPositions(){
  const wrap = byId("allPeriodsGrid"); wrap.innerHTML = "";
  const g = currentGame();
  const total = totalPeriodsForGame(g);
  // build a table-like view: each period as a column (responsive)
  const table = document.createElement("div");
  table.style.display="grid";
  table.style.gridTemplateColumns = `repeat(${total}, minmax(160px,1fr))`;
  table.style.gap = "8px";
  for(let p=0;p<total;p++){
    const col = document.createElement("div"); col.className="card";
    col.style.padding="8px";
    const header = document.createElement("div"); header.style.fontWeight="900"; header.textContent = periodLabel(p) + (p===g.liveP ? " â€¢ LIVE" : "");
    col.appendChild(header);
    col.appendChild(document.createElement("div"));
    // positions
    POSITIONS.forEach(pos=>{
      const row = document.createElement("div"); row.className="posRow";
      const tag = document.createElement("div"); tag.className="posTag"; tag.textContent = pos;
      const sel = document.createElement("select"); sel.style.flex="1";
      const opt0 = document.createElement("option"); opt0.value=""; opt0.textContent="â€”";
      sel.appendChild(opt0);
      currentTeamState.players.forEach(pl=>{
        const opt = document.createElement("option"); opt.value = pl.id;
        const played = regulationPeriodsPlayedHybrid(currentGame(), pl.id);
        opt.textContent = `${pl.name} â€¢ ${fmtPlayed(played)}/${basePeriods(currentTeamState.format)}`;
        sel.appendChild(opt);
      });
      sel.value = g.periods[p].assignments[pos] || "";
      sel.addEventListener("change", ()=> { g.periods[p].assignments[pos] = sel.value || null; // prevent duplicates
                                           for(const other of POSITIONS){ if(other !== pos && g.periods[p].assignments[other] === sel.value) g.periods[p].assignments[other] = null; }
                                           saveAll(); renderAll(); });
      row.appendChild(tag); row.appendChild(sel);
      // if LIVE period add quick +1 button for goal credit
      if(p === g.liveP && (pos==="GS" || pos==="GA")){
        const btn = document.createElement("button"); btn.className="primary small"; btn.textContent="+1";
        btn.addEventListener("click", ()=> scoreFromPosition(pos));
        row.appendChild(btn);
      }
      col.appendChild(row);
    });
    // bench count
    const benchCount = document.createElement("div"); benchCount.className="muted"; benchCount.style.marginTop="8px";
    benchCount.textContent = `${benchPlayersForP(g,p).length} on bench`;
    col.appendChild(benchCount);
    table.appendChild(col);
  }
  wrap.appendChild(table);
}

function benchPlayersForP(game, pIdx){
  const assigned = new Set(Object.values(game.periods[pIdx].assignments || {}).filter(Boolean));
  return currentTeamState.players.filter(p=>!assigned.has(p.id));
}

/* Court time hybrid: inferred unless sub-in sets playCredits to 0.5 */
function getPlayCredit(game, pIdx, playerId){
  if(!game.playCredits) game.playCredits = {};
  if(!game.playCredits[pIdx]) game.playCredits[pIdx] = {};
  return Number(game.playCredits[pIdx][playerId] || 0);
}
function bumpPlayCredit(game, pIdx, playerId, val){
  if(!game.playCredits) game.playCredits = {};
  if(!game.playCredits[pIdx]) game.playCredits[pIdx] = {};
  const cur = Number(game.playCredits[pIdx][playerId] || 0);
  game.playCredits[pIdx][playerId] = Math.max(cur, val);
}
function inferredPlayedForPeriod(game, pIdx, playerId){
  const assigned = Object.values(game.periods[pIdx]?.assignments || {}).filter(Boolean);
  return assigned.includes(playerId) ? 1 : 0;
}
function regulationPeriodsPlayedHybrid(game, playerId){
  const regMax = basePeriods(currentTeamState.format);
  let sum = 0;
  for(let i=0;i<regMax;i++){
    const credit = getPlayCredit(game, i, playerId);
    sum += credit > 0 ? credit : inferredPlayedForPeriod(game, i, playerId);
  }
  return sum;
}
function fmtPlayed(n){ return (Math.abs(n - Math.round(n)) < 1e-9) ? String(Math.round(n)) : n.toFixed(1) }

function renderBenchList(){
  const g = currentGame();
  const pIdx = g.selectedP;
  const wrap = byId("benchList"); wrap.innerHTML = "";
  const bench = benchPlayersForP(g, pIdx);
  bench.forEach(p=>{
    const div = document.createElement("div"); div.className="pill";
    const left = document.createElement("div"); left.innerHTML = `<div style="font-weight:900">${escapeHtml(p.name)}</div><div class="muted">On court: ${fmtPlayed(regulationPeriodsPlayedHybrid(g,p.id))}/${basePeriods(currentTeamState.format)}</div>`;
    const right = document.createElement("div"); right.style.display="flex"; right.style.gap="8px";
    // planned pos select
    const sel = document.createElement("select"); sel.innerHTML = `<option value="">Next: â€”</option>` + POSITIONS.map(x=>`<option value="${x}">${x}</option>`).join("");
    sel.value = g.plannedPositions && g.plannedPositions[pIdx] ? (g.plannedPositions[pIdx][p.id]||"") : "";
    sel.addEventListener("change", ()=> { if(!g.plannedPositions) g.plannedPositions={}; if(!g.plannedPositions[pIdx]) g.plannedPositions[pIdx]={}; g.plannedPositions[pIdx][p.id] = sel.value; saveAll(); });
    const btn = document.createElement("button"); btn.className="primary small"; btn.textContent="Sub In";
    btn.addEventListener("click", ()=> subInFromBench(p.id));
    right.appendChild(sel); right.appendChild(btn);
    div.appendChild(left); div.appendChild(right);
    wrap.appendChild(div);
  });
}

/* Stats */
function renderStats(){
  const wrap = byId("statsList"); wrap.innerHTML = "";
  if(!currentTeamState) return;
  const g = currentGame();
  const sorted = [...currentTeamState.players].sort((a,b)=> (g.playerStats?.[b.id]?.goalsTotal || 0) - (g.playerStats?.[a.id]?.goalsTotal || 0));
  sorted.forEach(p=>{
    const goals = g.playerStats?.[p.id]?.goalsTotal || 0;
    const played = regulationPeriodsPlayedHybrid(g,p.id);
    const div = document.createElement("div"); div.className="pill";
    div.innerHTML = `<div><div style="font-weight:900">${escapeHtml(p.name)}</div><div class="muted">Periods: ${fmtPlayed(played)}/${basePeriods(currentTeamState.format)}</div></div><div class="right"><div style="font-weight:900">${goals}</div><div class="muted">goals</div></div>`;
    wrap.appendChild(div);
  });
}

/* Timer functions */
let timerInterval = null;
function fmtTime(sec){ sec = Math.max(0, Math.floor(sec)); const m=String(Math.floor(sec/60)).padStart(2,"0"); const s=String(sec%60).padStart(2,"0"); return `${m}:${s}`; }

function tickTimer(){
  if(!currentTeamState) return;
  const g = currentGame();
  if(!g.timerRunning) return;
  const nowt = Date.now();
  if(!g.timerLastTick) g.timerLastTick = nowt;
  const delta = Math.floor((nowt - g.timerLastTick) / 1000);
  if(delta <= 0) return;
  g.timerLastTick = nowt;
  if(g.timerMode === "countdown"){
    g.timerRemaining = Math.max(0, g.timerRemaining - delta);
    if(g.timerRemaining === 0){
      g.timerRunning = false;
      clearInterval(timerInterval); timerInterval = null;
      handlePeriodEndOnTimer();
    }
  } else {
    // count up mode (play-on)
    g.timerRemaining += delta;
    // in play-on we check lead >=2 to auto-end
    const lead = Math.abs(totalHome(g) - totalAway(g));
    if(lead >= 2){
      g.timerRunning = false;
      clearInterval(timerInterval); timerInterval=null;
      g.gameEnded = true;
    }
  }
  saveAll();
  renderTimer();
  renderScores();
}

function startTimerLoop(){ if(timerInterval) return; timerInterval = setInterval(tickTimer, 250); }

function toggleTimer(){
  const g = currentGame(); if(g.gameEnded) return;
  g.timerRunning = !g.timerRunning;
  if(g.timerRunning){ g.timerLastTick = Date.now(); startTimerLoop(); } else { clearInterval(timerInterval); timerInterval=null; }
  saveAll(); renderTimer();
}

function resetTimer(){
  const g = currentGame();
  g.timerRunning = false;
  g.timerLastTick = 0;
  g.timerMode = "countdown";
  if(isOTIndex(g.selectedP)) g.timerRemaining = g.otMinutes * 60;
  else g.timerRemaining = g.baseMinutes * 60;
  clearInterval(timerInterval); timerInterval=null;
  saveAll(); renderTimer();
}

function renderTimer(){
  if(!currentTeamState) return;
  const g = currentGame();
  byId("timerDisplay").textContent = (g.timerMode === "countdown") ? fmtTime(g.timerRemaining) : fmtTime(g.timerRemaining);
  byId("timerStartBtn").textContent = g.timerRunning ? "Pause" : "Start";
}

function isOTIndex(idx){ return idx >= basePeriods(currentTeamState.format) }

function handlePeriodEndOnTimer(){
  const g = currentGame();
  const base = basePeriods(currentTeamState.format);
  const ot1 = base;
  const ot2 = base + 1;
  if(g.otCount === 2 && g.liveP === ot2 && isDraw(g)){
    // switch to play-on counting mode
    g.timerMode = "countup";
    g.timerRunning = true;
    g.timerLastTick = Date.now();
    startTimerLoop();
    saveAll();
    return;
  }
  // otherwise move to next or end
  endOrNextPeriod();
}

function totalHome(g){ return (g.periods || []).reduce((s,p)=>s+(p.homeScore||0),0) }
function totalAway(g){ return (g.periods || []).reduce((s,p)=>s+(p.awayScore||0),0) }
function isDraw(g){ return totalHome(g) === totalAway(g) }

/* Scoring and events */
function pushEvent(game, pIdx, type, payload){
  game.periods[pIdx].events = game.periods[pIdx].events || [];
  game.periods[pIdx].events.push({ type, payload, t: Date.now() });
}

function scoreTeam(which, delta){
  const g = currentGame(); if(g.gameEnded) return;
  const pIdx = g.liveP;
  if(which === "home") g.periods[pIdx].homeScore = Math.max(0, (g.periods[pIdx].homeScore||0) + delta);
  else g.periods[pIdx].awayScore = Math.max(0, (g.periods[pIdx].awayScore||0) + delta);
  pushEvent(g, pIdx, "score", { which, delta });
  saveAll(); renderAll();
}

function scoreFromPosition(pos){
  const g = currentGame(); if(g.gameEnded) return;
  const pIdx = g.liveP;
  const pid = g.periods[pIdx].assignments[pos];
  if(!pid) return alert(`Assign a player to ${pos} in LIVE period first.`);
  g.periods[pIdx].homeScore = (g.periods[pIdx].homeScore||0) + 1;
  if(!g.playerStats) g.playerStats = {};
  if(!g.playerStats[pid]) g.playerStats[pid] = { goalsTotal:0, goalsByP:[] };
  g.playerStats[pid].goalsTotal = (g.playerStats[pid].goalsTotal||0) + 1;
  g.playerStats[pid].goalsByP[pIdx] = (g.playerStats[pid].goalsByP[pIdx]||0) + 1;
  pushEvent(g, pIdx, "playerGoal", { pid, pos });
  saveAll(); renderAll();
}

function undo(){
  const g = currentGame(); if(g.gameEnded) return;
  const pIdx = g.liveP;
  const events = g.periods[pIdx].events || [];
  const last = events.pop();
  if(!last) return;
  if(last.type === "score"){
    const {which, delta} = last.payload; if(which==="home") g.periods[pIdx].homeScore = Math.max(0, g.periods[pIdx].homeScore - delta); else g.periods[pIdx].awayScore = Math.max(0, g.periods[pIdx].awayScore - delta);
  } else if(last.type === "playerGoal"){
    const {pid} = last.payload; g.periods[pIdx].homeScore = Math.max(0, g.periods[pIdx].homeScore - 1);
    if(g.playerStats && g.playerStats[pid]){ g.playerStats[pid].goalsTotal = Math.max(0, g.playerStats[pid].goalsTotal - 1); g.playerStats[pid].goalsByP[pIdx] = Math.max(0, (g.playerStats[pid].goalsByP[pIdx]||0) -1); }
  }
  saveAll(); renderAll();
}

/* Sub in from bench */
function subInFromBench(playerId){
  const g = currentGame();
  const pIdx = g.selectedP;
  const planned = g.plannedPositions && g.plannedPositions[pIdx] ? g.plannedPositions[pIdx][playerId] : "";
  if(!planned) return alert("Set planned Next position first for this player.");
  const outgoing = g.periods[pIdx].assignments[planned] || null;
  // credit .5 for both players if regulation
  const regMax = basePeriods(currentTeamState.format);
  if(pIdx < regMax){
    bumpPlayCredit(g, pIdx, playerId, 0.5);
    if(outgoing && outgoing !== playerId) bumpPlayCredit(g, pIdx, outgoing, 0.5);
  }
  g.periods[pIdx].assignments[planned] = playerId;
  // clear planned
  if(g.plannedPositions && g.plannedPositions[pIdx]) g.plannedPositions[pIdx][playerId] = "";
  // remove player from other positions in same period
  for(const pos of POSITIONS){ if(pos !== planned && g.periods[pIdx].assignments[pos] === playerId) g.periods[pIdx].assignments[pos] = null; }
  saveAll(); renderAll();
}

/* Period end / OT behavior */
function endOrNextPeriod(){
  const g = currentGame();
  if(g.gameEnded) return;
  const base = basePeriods(currentTeamState.format);
  const lastIndex = totalPeriodsForGame(g) - 1;
  const ot1Index = base;
  const ot2Index = base + 1;
  // if OT flow: always go OT1 -> OT2 -> end
  if(g.otCount === 2 && g.liveP === ot1Index){
    g.liveP = ot2Index; g.selectedP = ot2Index; resetTimer(); saveAll(); renderAll(); return;
  }
  if(g.liveP >= lastIndex){
    // end game
    g.gameEnded = true; g.timerRunning = false; clearInterval(timerInterval); timerInterval=null; saveAll(); renderAll(); return;
  }
  // otherwise advance
  g.liveP += 1; g.selectedP = g.liveP; resetTimer(); saveAll(); renderAll();
}

function reopenGame(){
  const g = currentGame(); g.gameEnded = false; saveAll(); renderAll();
}

/* OT starters */
function startOT(){
  const g = currentGame();
  if(!g.gameEnded && !isDraw(g)) return alert("OT only when game ended and is a draw");
  // add two OT periods
  g.otCount = 2;
  g.periods.push(emptyPeriod()); g.periods.push(emptyPeriod());
  g.liveP = basePeriods(currentTeamState.format);
  g.selectedP = g.liveP;
  g.timerRunning = false; g.timerMode="countdown"; g.timerRemaining = g.otMinutes*60; saveAll(); renderAll();
}

/* Copy positions to next */
function copyToNext(){
  const g = currentGame();
  const from = g.selectedP;
  const to = Math.min(totalPeriodsForGame(g)-1, from+1);
  if(to===from) return alert("No next period");
  g.periods[to].assignments = JSON.parse(JSON.stringify(g.periods[from].assignments || {}));
  saveAll(); renderAll(); alert(`Copied ${periodLabel(from)} to ${periodLabel(to)}`);
}

/* Generate teams (simple round-robin-ish balancing) */
function openGenerateModal(){ byId("generateModal").style.display="flex" }
function closeGenerateModal(){ byId("generateModal").style.display="none" }

function generateTeamsForTournament(count, overwrite){
  const team = currentTeamState;
  if(!team) return;
  // preserve manually added games (we'll keep those with round <= existingManualCount if not overwrite)
  const existing = team.games.slice();
  const manualCount = existing.length;
  let startIndex = manualCount;
  if(overwrite){
    team.games = [];
    startIndex = 0;
  }
  // ensure players list
  const players = team.players.map(p=>p.id);
  // naive algorithm: for each game create periods and rotate players to try to equalize plays
  for(let gI = startIndex; gI < count; gI++){
    const g = newEmptyGame(gI+1, team.players, team.format);
    // for each period assign the first 7 players rotated by offset
    const baseP = basePeriods(team.format);
    for(let p=0;p<baseP;p++){
      const offset = (gI + p) % players.length;
      // assign positions to players offset.. offset+6
      const slice = [];
      for(let k=0;k<7;k++){ slice.push(players[(offset + k) % players.length]); }
      POSITIONS.forEach((pos, idx)=> g.periods[p].assignments[pos] = slice[idx]);
    }
    team.games.push(g);
  }
  team.currentGameIndex = Math.max(0, team.games.length-1);
  saveAll(); renderAll();
  alert(`Generated ${count - startIndex} game(s).`);
}

/* ---------- UI wiring ---------- */

byId("addCompBtn").addEventListener("click", ()=> byId("compModal").style.display="flex");
byId("closeCompModal").addEventListener("click", ()=> byId("compModal").style.display="none");
byId("createCompBtn").addEventListener("click", ()=>{
  const name = (byId("compNameField").value||"").trim(); if(!name) return alert("Name required");
  const id = uid(); indexStore.comps.push({ id, name, teams:[] }); indexStore.currentCompId = id; indexStore.currentTeamId = null; saveIndex(indexStore); ensureTeamState(); byId("compModal").style.display="none"; renderAll();
});

byId("addTeamBtn").addEventListener("click", ()=> byId("teamModal").style.display="flex");
byId("closeTeamModal").addEventListener("click", ()=> byId("teamModal").style.display="none");
byId("createTeamBtn").addEventListener("click", ()=>{   const comp = indexStore.comps.find(c=>c.id===indexStore.currentCompId);   if(!comp) return alert("Create a competition first.");    const name = (byId("newTeamName").value||"").trim() || `Team ${comp.teams.length+1}`;   const format = document.querySelector('input[name="teamFormat"]:checked')?.value || "quarters";    const id = uid();   comp.teams.push({ id, name, format });   indexStore.currentTeamId = id;    // create team state   const players = [];   const state = {     id,     teamName: name,     format,     players,     games: [],     currentGameIndex: 0   };   saveTeam(id, state);    ensureTeamState();   saveAll();   byId("teamModal").style.display="none";   renderAll();    // ðŸ”´ FORCE PLAYERS MODAL (this was missing)   openPlayerModal(); });
  const comp = indexStore.comps.find(c=>c.id===indexStore.currentCompId);
  if(!comp) return alert("Create a competition first.");
  const name = (byId("newTeamName").value||"").trim() || `Team ${comp.teams.length+1}`;
  const format = document.querySelector('input[name="teamFormat"]:checked')?.value || "quarters";
  const id = uid(); comp.teams.push({ id, name, format }); indexStore.currentTeamId = id;
  // create team state
  const players = Array.from({length:10},(_,i)=>({ id: uid(), name:`Player ${i+1}`, pos1:"", pos2:"" }));
  const state = { id, teamName: name, format, players, games:[ newEmptyGame(1, players, format) ], currentGameIndex:0 };
  saveTeam(id, state);
  ensureTeamState();
  saveAll();
  byId("teamModal").style.display="none";
  renderAll();
});

byId("openAddPlayerModal").addEventListener("click", ()=> { openPlayerModal(); });
function openPlayerModal(player){
  byId("playerModal").style.display="flex";
  if(player){
    byId("playerModalTitle").textContent = "Edit Player";
    byId("playerNameField").value = player.name;
    byId("pos1Field").value = player.pos1 || "";
    byId("pos2Field").value = player.pos2 || "";
    byId("savePlayerBtn").dataset.editId = player.id;
  } else {
    byId("playerModalTitle").textContent = "Add Player";
    byId("playerNameField").value = "";
    byId("pos1Field").value = "";
    byId("pos2Field").value = "";
    byId("savePlayerBtn").dataset.editId = "";
  }
  // auto-select name on focus
  setTimeout(()=>{ byId("playerNameField").focus(); byId("playerNameField").select(); }, 20);
}
byId("closePlayerModal").addEventListener("click", ()=> byId("playerModal").style.display="none");

byId("savePlayerBtn").addEventListener("click", ()=>{
  const name = (byId("playerNameField").value||"").trim();
  const pos1 = (byId("pos1Field").value||"").trim().toUpperCase();
  const pos2 = (byId("pos2Field").value||"").trim().toUpperCase();
  if(!name) return alert("Name required");
  if(!currentTeamState) return alert("No team selected");
  const editId = byId("savePlayerBtn").dataset.editId;
  if(editId){
    const p = currentTeamState.players.find(x=>x.id===editId);
    if(p){ p.name=name; p.pos1=pos1; p.pos2=pos2; }
  } else {
    if(currentTeamState.players.length >= MAX_PLAYERS) return alert(`Max ${MAX_PLAYERS}`);
    const p = { id: uid(), name, pos1, pos2 };
    currentTeamState.players.push(p);
    // add to all games playerStats
    currentTeamState.games.forEach(g=> { if(!g.playerStats) g.playerStats={}; g.playerStats[p.id]={goalsTotal:0,goalsByP:[]} });
  }
  saveAll(); byId("playerModal").style.display="none"; renderAll();
});

function removePlayer(pid){
  if(!confirm("Remove player?")) return;
  currentTeamState.players = currentTeamState.players.filter(p=>p.id!==pid);
  // remove from assignments and stats
  currentTeamState.games.forEach(g=>{ g.periods.forEach(p=>{ for(const pos of POSITIONS) if(p.assignments[pos]===pid) p.assignments[pos]=null }); if(g.playerStats) delete g.playerStats[pid]; });
  saveAll(); renderAll();
}

/* Player position filter helpers (simple): when user types e.g. 'W' suggest WA WD etc. We'll just handle small input matching */
byId("pos1Field").addEventListener("input", (e)=> { filterPosInput(e.target) });
byId("pos2Field").addEventListener("input", (e)=> { filterPosInput(e.target) });
function filterPosInput(inputEl){
  const q = (inputEl.value||"").toUpperCase();
  if(!q) return; // we allow free text but will auto-complete suggestions inline
  const matched = POSITIONS.filter(p=>p.startsWith(q));
  if(matched.length===1) { inputEl.value = matched[0]; inputEl.select(); }
  else if(matched.length>1){ /* do nothing â€” user can type more */ }
}

/* Event wiring: scoring */
byId("homePlus").addEventListener("click", ()=> scoreTeam("home", +1));
byId("homeMinus").addEventListener("click", ()=> scoreTeam("home", -1));
byId("awayPlus").addEventListener("click", ()=> scoreTeam("away", +1));
byId("awayMinus").addEventListener("click", ()=> scoreTeam("away", -1));
byId("gsPlus").addEventListener("click", ()=> scoreFromPosition("GS"));
byId("gaPlus").addEventListener("click", ()=> scoreFromPosition("GA"));
byId("undoBtn").addEventListener("click", undo);

byId("addGameBtn").addEventListener("click", ()=>{
  if(!currentTeamState) return alert("Select a team");
  const next = currentTeamState.games.length + 1;
  currentTeamState.games.push(newEmptyGame(next, currentTeamState.players, currentTeamState.format));
  currentTeamState.currentGameIndex = currentTeamState.games.length-1;
  saveAll(); renderAll();
});

byId("activateFinalsBtn").addEventListener("click", ()=>{
  if(!currentTeamState) return;
  // mark comp meta that finals active (simple flag)
  const comp = indexStore.comps.find(c=>c.id===indexStore.currentCompId);
  if(comp){ comp.finalsActive = true; saveAll(); alert("Finals activated for this competition"); }
});

byId("generateBtn").addEventListener("click", ()=> openGenerateModal());
byId("closeGenerateModal").addEventListener("click", ()=> closeGenerateModal());
byId("runGenerateBtn").addEventListener("click", ()=>{
  const count = Number(byId("generateGamesCount").value||5);
  const overwrite = byId("generateOverwrite").checked;
  generateTeamsForTournament(count, overwrite);
  closeGenerateModal();
});

/* Timer controls */
(function initMinutesSelect(){
  const sel = byId("minutesSelect"); sel.innerHTML = "";
  const list = currentTeamState && currentTeamState.format==="halves" ? TOURN_MINUTES : LEAGUE_MINUTES;
  (list || LEAGUE_MINUTES).forEach(m=>{ const o=document.createElement("option"); o.value=m; o.textContent=`${m} min`; sel.appendChild(o); });
  sel.addEventListener("change",(e)=>{ const g=currentGame(); g.baseMinutes = Number(e.target.value); if(!g.timerRunning && !isOTIndex(g.selectedP)) g.timerRemaining = g.baseMinutes * 60; saveAll(); renderAll(); });
})();

byId("timerStartBtn").addEventListener("click", ()=> { toggleTimer(); });
byId("timerResetBtn").addEventListener("click", ()=> { resetTimer(); });

/* Copy / export */
byId("copySummaryBtn").addEventListener("click", ()=> { copyText(buildGameSummary(currentGame())); });
byId("copySeasonBtn").addEventListener("click", ()=> { copyText(buildCompetitionSummary()); });

function copyText(t){
  navigator.clipboard?.writeText(t).then(()=> alert("Copied to clipboard."), ()=> alert("Copy failed."));
}

/* Export / Import modals */
byId("exportBtn").addEventListener("click", ()=> {
  const payload = { indexStore };
  byId("syncTextarea").value = btoa(unescape(encodeURIComponent(JSON.stringify(payload))));
  byId("syncModal").style.display="flex";
});
byId("importBtn").addEventListener("click", ()=> byId("syncModal").style.display="flex");
byId("closeSyncModal").addEventListener("click", ()=> byId("syncModal").style.display="none");
byId("exportTeamBtn").addEventListener("click", ()=> {
  const payload = { indexStore, teams: indexStore.comps.map(c=>({id:c.id, teams:c.teams})) };
  byId("syncTextarea").value = btoa(unescape(encodeURIComponent(JSON.stringify(payload))));
});
byId("importTeamBtn").addEventListener("click", ()=> {
  const raw = byId("syncTextarea").value.trim();
  if(!raw) return alert("Paste export text.");
  try{
    const payload = JSON.parse(decodeURIComponent(escape(atob(raw))));
    if(payload.indexStore) { indexStore = payload.indexStore; saveIndex(indexStore); ensureTeamState(); saveAll(); renderAll(); byId("syncModal").style.display="none"; alert("Imported."); }
  }catch(e){ alert("Import failed"); }
});

/* Helpers for building summaries */
function buildGameSummary(g){
  const team = currentTeamState.teamName || "Home";
  const opp = g.opponent || "Away";
  let lines = [`Game ${g.round} â€¢ ${g.roundName || ""} ${g.gameDate||""}`, `${team} ${totalHome(g)} - ${totalAway(g)} ${opp}`];
  for(let p=0;p<basePeriods(currentTeamState.format);p++){
    lines.push(`${periodLabel(p)}: ${currentTeamState.teamName} ${g.periods[p].homeScore} - ${g.periods[p].awayScore} ${opp}`);
  }
  if(g.otCount) lines.push(`OT: ${team} ${totalHome(g)} - ${totalAway(g)} ${opp}`);
  lines.push(""); lines.push("Rotations:");
  for(let p=0;p<totalPeriodsForGame(g);p++){
    const a = g.periods[p].assignments || {};
    const line = POSITIONS.map(pos=>`${pos}:${a[pos]?playerName(a[pos]):"â€”"}`).join(" | ");
    lines.push(`${periodLabel(p)}: ${line}`);
  }
  return lines.join("\n");
}
function buildCompetitionSummary(){
  const comp = indexStore.comps.find(c=>c.id===indexStore.currentCompId) || {name:"Competition", teams:[]};
  const lines = [`Competition: ${comp.name}`];
  comp.teams.forEach(t=>{
    const teamState = loadTeam(t.id);
    if(!teamState) return;
    lines.push(`Team: ${t.name} â€” Games: ${teamState.games.length}`);
  });
  return lines.join("\n");
}

function playerName(id){ const p = currentTeamState.players.find(x=>x.id===id); return p ? p.name : "â€”"; }
function escapeHtml(s){ return (s||"").replace(/[&<>"']/g,m=>({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[m])) }

/* render summary parts */
function renderScoresAndFinalBanner(){
  const g = currentGame();
  byId("homeScore").textContent = totalHome(g);
  byId("awayScore").textContent = totalAway(g);
  const liveA = g.periods[g.liveP]?.assignments || {};
  byId("gsName").textContent = liveA.GS ? playerName(liveA.GS) : "â€”";
  byId("gaName").textContent = liveA.GA ? playerName(liveA.GA) : "â€”";
  // final banner
  const fb = byId("finalBanner"); const ft = byId("finalBannerText");
  fb.style.display = "none";
  if(g.gameEnded){
    fb.style.display="block";
    const diff = totalHome(g) - totalAway(g);
    const team = currentTeamState.teamName || "Home";
    if(diff>0){ fb.className="finalBanner win"; ft.textContent = `${team} won by ${diff}` }
    else if(diff<0){ fb.className="finalBanner loss"; ft.textContent = `${team} lost by ${Math.abs(diff)}` }
    else { fb.className="finalBanner draw"; ft.textContent = `Draw` }
  } else fb.style.display="none";
}

/* Render all */
function renderAll(){
  ensureTeamState();
  renderCompTabs();
  renderTeamTabs();
  renderGameHeader();
  if(!currentTeamState) { // show minimal UI
    // hide other cards
    ["playersCard","periodCard","positionsCard","statsCard","notesCard","gameCard"].forEach(id=>{ const el=byId(id); if(el) el.style.display = (id==="gameCard"?"block":"none")});
    return;
  }
  renderPlayers();
  renderPeriodSeg();
  renderAllPeriodsPositions();
  renderBenchList();
  renderStats();
  renderScoresAndFinalBanner();
  renderTimer();
  saveAll();
}

/* initial setup */
if(!indexStore.comps.length){
  // create default comp placeholder to ease testing
  const compId = uid(); indexStore.comps.push({ id: compId, name:"My Competition", teams:[] }); indexStore.currentCompId = compId; saveIndex(indexStore);
}
ensureTeamState();
renderAll();

/* init event binding for period buttons created dynamically */
document.addEventListener("click", (e)=> {
  if(e.target && e.target.id === "copyToNextBtn") copyToNext();
  if(e.target && e.target.id === "generateBtn") openGenerateModal();
  if(e.target && e.target.id === "homePlus") scoreTeam("home", +1);
});

/* auto-save periodically */
setInterval(()=> saveAll(), 5000);

/* show how-to on first load */
if(!localStorage.getItem("benchboss_howto_seen_v2")){
  alert("Welcome to Bench Boss V2 â€” create a Competition first, then add Teams and Players. The How-to button has quick tips.");
  localStorage.setItem("benchboss_howto_seen_v2", "1");
}

/* quick utilities used in UI */
function isDraw(g){ return totalHome(g)===totalAway(g) }

/* small helpers for interactions */
byId("teamName").addEventListener("input", (e)=> { if(currentTeamState){ currentTeamState.teamName = e.target.value; // also update comp meta name
  const comp = indexStore.comps.find(c=>c.id===indexStore.currentCompId); if(comp){ const tm = comp.teams.find(t=>t.id===indexStore.currentTeamId); if(tm) tm.name = e.target.value; } saveAll(); renderTeamTabs(); } });

byId("gameName").addEventListener("input",(e)=>{ const g=currentGame(); g.roundName=e.target.value; saveAll(); renderGameHeader(); });
byId("gameDate").addEventListener("input",(e)=>{ currentGame().gameDate=e.target.value; saveAll(); renderGameHeader(); });
byId("opponent").addEventListener("input",(e)=>{ currentGame().opponent=e.target.value; saveAll(); renderAll(); });

/* small helpers: import players from other team */
byId("importPlayersFromTeamBtn").addEventListener("click", ()=>{
  const srcId = byId("importFromSelect").value; if(!srcId) return alert("Pick a source team");
  const srcState = loadTeam(srcId); if(!srcState || !srcState.players.length) return alert("Source has no players");
  const names = srcState.players.map(p=>({name:p.name,pos1:p.pos1||"",pos2:p.pos2||""}));
  // fill into pending modal for next team create or use when creating team
  alert(`Imported ${names.length} players into new team creation (will be used when you hit Create Team).`);
});

/* expose some functions for debugging in console */
window.bb = { indexStore, currentTeamState, saveAll, renderAll };

/* tiny utilities used earlier but declared after */
function isOTIndex(idx){ return idx >= basePeriods(currentTeamState.format) }

</script>
</body>
</html>